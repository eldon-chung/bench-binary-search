# Some Benchmarks Between Binary Search and Various Implementations of Linear Search
Just some basic benchmarks I did between the two algorithms.
The specific task here is to search for a specific `uint32_t` in a file.

## Setup
For files of varying sizes (in powers of 2 starting from 4KB up to 2GB),
the appropriate number of 32-bit integers are sampled and then sorted.
Then, 3 sets of queries are generated:

* The `n` queries are generated by taking integers at every 10th percentile
and then removed from the list. So they are guaranteed to not be present.
* The `q` queries are generated by taking integers at every 10th percentile.
* The `p` queries are just sampled from the list, and then sorted.

Look into `generate.py` for details.

We run our benchmarks using `hyperfine` and we do 5 warmup rounds before the
actual sampling. This is to make sure that the caches are warm.

## A Brief Explanation on the Algorithms
You can look up the source code in `src/search.cpp` to look at all the implementations.
Besides a really basic iterative binary search, there are 6 variants of linear search, 
each some combination of early termination, vectorisation, and amount of loading (for 
vectorised variants).

The `twin_loading` variants have instructions to load 16 `uint32_t` integers 
at a go, rather than 8.

# Building
Just hit `make` and it should compile as long as you have `clang++`.
Hit `./verify` to verify that all the algorithms work.
If there is a test case that fails, the script will stop on the last case
along with query for which it has failed.

# Generating Test Cases
Make sure you have `numpy` installed. Run `make tests` to create a new batch of tests.

# Running Benchmarks
We sample running times using `hyperfine`, make sure you have it installed.
Hit `./bench_all.sh` to sample running times for all possible tests.

There is also `./sample.sh` which takes in a test name, a query type and a value between 0 and 9.
For example `./sample.sh n-chunked-random-s-29-w-uint32 n 5` runs `hyperfine` with all 7 algorithms
on `n-chunked-random-s-29-w-uint32.case` for a negative query whose value is around the median point.

There is also `./bench.sh` which takes in a query type and a value between 0 and 9.
For example `./bench.sh p 9` runs `hyperfine` with all 7 algorithms
on all generated file sizes for a positive query whose value is around the end.

# Analysing the Results
I have a (really badly written) numpy notebook that plots graphs with either the 
size as the x-axis or the position of the query as the x-axis. 

# Citation
Thanks to hyperfine:
Peter, D. (2022). hyperfine (Version 1.15.0) [Computer software]. https://github.com/sharkdp/hyperfine